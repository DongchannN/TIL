# Cache
 기본적으로 통신을 할 때 서버와 클라이언트가 통신을 한다. 요청한 데이터가 반복적인 경우에 클라이언트에서 서버까지 계속 요청하는 것은 시간도 많이 걸리고 트래픽 소요가 있다.

 조금 더 빠른 통신을 위하여 클라이언트와 서버 사이에 캐쉬서버를 배치할 수 있다. 요청한 데이터가 캐싱이 되어있는 경우 서버까지 갈 필요 없이 캐쉬서버에서 바로 데이터를 받을 수 있을 것이다.

## #1. 캐쉬 동작원리
- Client의 요청이 Cache Server에 전달된다.
- 캐시된 문서가 있는지 조회한다.
- 존재한다면 문서의 **유효성 검사**를 하고 없으면 Server로 요청을 전달한다.
- 아직 문서가 유효하다면 새로 생성한 Header와 기존의 Body를 조합한다.
- 유효하지 않다면 Server에 요청을 전달한다.
- Client에게 응답을 보낸다.

## #2. HTTP Request Header의 캐쉬 지시자

### 1. Pragma
 HTTP/1.0의 헤더 옵션 중 하나, HTTP/1.1의 Cache-Control 헤더가 생기기 전 그것과 동일한 역할을 하는 대용헤더로 사용

 일반적으로 사용하지 않는 것이 좋으나 HTTP/1.0과의 하위 호환성을 위해 남아있다.

### 2. Expires
  GMT를 사용해 날짜를 지정하여 유효기간을 정한다.

### 3. Cache-Control

- `max-age=600`  : 요청 시간으로부터 상대적 시간을 표시. Expires와 같이 명시된 경우 Expires는 무시된다.

- `s-maxage=600` : share cache에만 적용된다. max-age나 Expires보다 우선시.

- `public` : 모든 사람과 중간 서버가 캐시를 저장할 수 있다.

- `private` : 가장 끝의 사용자 브라우저만 캐시를 저장할 수 있다.

- `no-cache` : 캐싱을 허용하며 사용전에 필수로 유효성 체크를 해야한다.

- `no-store` : 캐싱을 금지한다.

- `no-transform` : 성능 향상을 위해 최적화된 포멧으로 이미지나 문서들은 변환하는 경우가 있다. 이러한 것들을 금지시킨다.

- `must-revalidate` : 내부 유효성 체크를 허용하지 않고 항상 서버로 유효성 체크를 하게 한다.

- `proxy-revalidate` : proxy caches에서만 적용되는 must-revalidate와 유사한 개념.


## #3. 유효성 검사 (Cache Validation)
유효성 검사는 현재 캐쉬하여 가지고있는 데이터가 최신인지 확인하는 것이다. 유효성 검사를 하기 위해 ‘ETag’를 사용하게 된다.

### ETag (Entity tag) ?
 특정 버전의 리소스를 확인하는 일종의 지문과 같은 역할이다. HTTP서버들은 정적인 컨텐츠에 대해 ETag와 Last-Modified를 생성하여 헤더에 추가한다. 이는 HTTP서버 관리자가 원하는대로 수정할 수 없다.

- 1.  최초 요청 시 응답코드 200OK와 함께 데이터를 받는다. 이때 응답 헤더에는 ETag가 붙어있다.
- 2. 다시 요청을 할 때 이전에 받은 ETag 값이 요청 헤더의 If-None-Match 속성의 값으로 붙게된다.
- 3.Server는 받은 ETag값을 대조하고 변경된 사항이 없으면 304 Not Modified, 변경된 사항이 있다면 새로운 데이터와 업데이트된 ETag를 200OK와 함께 응답한다.
